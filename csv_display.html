<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>CS415 Project 1a — Scatterplots</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --fg:#111827; --muted:#6b7280; --border:#e5e7eb; --card:#ffffff; --bg:#f8fafc; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif; }
  .container { max-width: 1040px; margin: 24px auto; padding: 0 16px; }
  h1 { font-size: 1.25rem; margin: 0 0 12px 0; }
  .card { background: var(--card); border:1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; }
  .row { display:flex; gap:12px; flex-wrap: wrap; align-items: center; }
  label { display:flex; align-items:center; gap:8px; }
  input[type="file"] { padding:6px 8px; }
  #chart { height: 520px; position: relative; }
  .legend { display:flex; gap:12px; flex-wrap: wrap; margin-top: 8px; }
  .badge { display:inline-flex; align-items:center; gap:8px; padding:4px 10px; border:1px solid var(--border); border-radius: 999px; background:#fff; font-size: 12px; }
  .dot { width:10px; height:10px; border-radius:999px; display:inline-block; }
  .footer { color: var(--muted); font-size: .9rem; margin-top: 12px; }
  .axis text { font-size: 12px; fill: #374151; }
  .axis path, .axis line { stroke: #94a3b8; }
  .grid line { stroke: #e5e7eb; }
  .grid .domain { display: none; }
  button { padding: 6px 10px; border: 1px solid var(--border); border-radius: 8px; background: #f9fafb; cursor: pointer; }
  button:hover { background:#f3f4f6; }
  .tooltip {
    position: fixed;
    pointer-events: none;
    background: #fff;
    border: 1px solid var(--border);
    box-shadow: 0 4px 14px rgba(0,0,0,0.12);
    border-radius: 10px;
    padding: 8px 10px;
    font-size: 12px;
    color: var(--fg);
    z-index: 20;
    white-space: nowrap;
  }
  .tooltip .hdr { font-weight: 600; margin-bottom: 2px; }
  .tooltip .sub { color: var(--muted); }
</style>
</head>
<body>
  <div class="container">
    <h1>CS415 Project 1a — Scatterplots (CSV Loader)</h1>

    <div class="card">
      <div class="row">
        <label>CSV file <input type="file" id="file" accept=".csv" /></label>

        <label>X scale
          <select id="xScale">
            <option value="linear" selected>linear</option>
            <option value="log">log</option>
          </select>
        </label>

        <button id="clear">Clear</button>
      </div>

      <div class="footer" id="schemaHint">
        Load one of your generated CSVs: fib_scatter.csv, gcd_scatter.csv, exp_scatter.csv, sort_best_scatter.csv, sort_avg_scatter.csv, sort_worst_scatter.csv
      </div>
    </div>

    <div id="chart" class="card"></div>
    <div id="legend" class="legend"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const fileInput = document.getElementById('file');
    const xScaleSel = document.getElementById('xScale');
    const clearBtn = document.getElementById('clear');
    const schemaHint = document.getElementById('schemaHint');

    // Current dataset state
    let rawRows = [];
    let headers = [];
    let xField = null;        // 'k' or 'n' or 'N'
    let numericFields = [];   // all numeric columns
    let seriesFields = [];    // numeric columns excluding xField

    // Tooltip (global)
    const tooltip = d3.select('body').append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0);

    function parseCsv(text) {
      const rows = d3.csvParse(text.replace(/\r\n/g, '\n').trim());
      if (!rows.length) return {rows: [], headers: []};
      const hdrs = rows.columns ? rows.columns.slice() : Object.keys(rows[0]);
      return {rows, headers: hdrs};
    }

    function detectXField(hdrs) {
      if (hdrs.includes('N')) return 'N';
      if (hdrs.includes('n')) return 'n';
      if (hdrs.includes('k')) return 'k';
      return hdrs.length ? hdrs[0] : null;
    }

    function toNumberOrNaN(v) {
      const n = +v;
      return Number.isFinite(n) ? n : NaN;
    }

    function buildSchema(rows, hdrs) {
      xField = detectXField(hdrs);

      // Convert numeric-looking cells to numbers and collect numeric columns
      const numeric = new Set();
      rows.forEach(r => {
        hdrs.forEach(h => {
          const n = toNumberOrNaN(r[h]);
          if (Number.isFinite(n)) {
            r[h] = n;
            numeric.add(h);
          }
        });
      });

      numericFields = Array.from(numeric);

      // Ensure xField is numeric; otherwise choose a numeric fallback
      if (!numericFields.includes(xField)) {
        const fallback = numericFields.length ? numericFields[0] : null;
        xField = fallback || xField;
      }

      seriesFields = numericFields.filter(h => h !== xField);

      // Prefer common series ordering (cosmetic)
      const priority = [
        'fib','additions','D(n)',
        'dec_by_one','dec_by_factor','divide_and_conquer',
        'insertion_sort','selection_sort',
        'elapsed_ms','ops_total'
      ];
      seriesFields.sort((a,b) => {
        const ia = priority.indexOf(a);
        const ib = priority.indexOf(b);
        if (ia === -1 && ib === -1) return a.localeCompare(b);
        if (ia === -1) return 1;
        if (ib === -1) return -1;
        return ia - ib;
      });

      schemaHint.textContent =
        `Detected X = "${xField}". Plotting series: ${seriesFields.length ? seriesFields.join(', ') : '(none)'}`;
    }

    function cssSafe(s) {
      return String(s).replace(/[^a-zA-Z0-9_-]/g, '_');
    }

    function colorFor(field) {
      // deterministic palette by field name
      const palette = [
        '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b',
        '#e377c2','#7f7f7f','#bcbd22','#17becf'
      ];
      let h = 0;
      for (let i = 0; i < field.length; i++) h = (h * 31 + field.charCodeAt(i)) >>> 0;
      return palette[h % palette.length];
    }

    function render() {
      const container = d3.select('#chart');
      container.selectAll('*').remove();
      d3.select('#legend').html('');

      if (!rawRows.length || !xField || !seriesFields.length) {
        container.append('div').style('color', '#6b7280')
          .text('Load a CSV with a numeric x-column (k/n/N) and at least one numeric series column.');
        return;
      }

      // Filter rows where x exists; each series will filter y individually
      const rowsX = rawRows
        .filter(r => Number.isFinite(r[xField]) && r[xField] > 0)
        .slice()
        .sort((a,b)=>a[xField]-b[xField]);

      if (!rowsX.length) {
        container.append('div').style('color', '#6b7280')
          .text('No valid rows with numeric X after filtering.');
        return;
      }

      const margin = {top: 24, right: 34, bottom: 56, left: 76};
      const width = Math.max(360, container.node().clientWidth) - margin.left - margin.right;
      const height = 520 - margin.top - margin.bottom;

      const svg = container.append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      const xmin = d3.min(rowsX, d => d[xField]);
      const xmax = d3.max(rowsX, d => d[xField]);

      // y max across ALL series
      const ymax = d3.max(rowsX, d => d3.max(seriesFields, f => Number.isFinite(d[f]) ? d[f] : NaN));
      if (!Number.isFinite(ymax)) {
        container.append('div').style('color', '#6b7280')
          .text('No numeric Y values found for the detected series columns.');
        return;
      }

      const xMode = xScaleSel.value || 'linear';
      const x = (xMode === 'log')
        ? d3.scaleLog().domain([Math.max(1e-9, xmin), xmax]).range([0, width])
        : d3.scaleLinear().domain([xmin, xmax]).range([0, width]);

      const y = d3.scaleLinear().domain([0, ymax]).nice().range([height, 0]);

    const sciFormat = d3.format(".2e");   // scientific notation, 2 decimals
    const compactFormat = d3.format(".2s"); // compact 1.2M style

    const xAxis = (xMode === 'log')
      ? d3.axisBottom(x)
          .ticks(8)
          .tickFormat(d => sciFormat(d))
      : d3.axisBottom(x)
          .ticks(10)
          .tickFormat(d => {
            // switch to scientific notation for large values
            return Math.abs(d) >= 1e6 ? sciFormat(d) : d;
      });
      const yAxis = d3.axisLeft(y).ticks(8);

      const xGrid = d3.axisBottom(x).ticks(10).tickSize(-height).tickFormat('');
      const yGrid = d3.axisLeft(y).ticks(8).tickSize(-width).tickFormat('');

      g.append('g').attr('class','grid').attr('transform', `translate(0,${height})`).call(xGrid);
      g.append('g').attr('class','grid').call(yGrid);

      g.append('g').attr('class','axis').attr('transform', `translate(0,${height})`).call(xAxis);
      g.append('g').attr('class','axis').call(yAxis);

      g.append('text')
        .attr('x', width/2).attr('y', height+42)
        .attr('text-anchor','middle')
        .text(xField);

      g.append('text')
        .attr('transform','rotate(-90)')
        .attr('x', -height/2).attr('y', -56)
        .attr('text-anchor','middle')
        .text('value');

      // Line generator
      const line = d3.line()
        .x(d => x(d[xField]))
        .y(d => y(d.__y))
        .curve(d3.curveMonotoneX);

      // Draw each series: line + points
      seriesFields.forEach(field => {
        const col = colorFor(field);

        const series = rowsX
          .filter(r => Number.isFinite(r[field]))
          .map(r => ({...r, __y: r[field]}));

        if (!series.length) return;

        g.append('path')
          .datum(series)
          .attr('fill','none')
          .attr('stroke', col)
          .attr('stroke-width', 2.5)
          .attr('d', line);

        g.selectAll(`.pt-${cssSafe(field)}`)
          .data(series)
          .enter().append('circle')
          .attr('class', `pt-${cssSafe(field)}`)
          .attr('r', 4)
          .attr('cx', d => x(d[xField]))
          .attr('cy', d => y(d.__y))
          .attr('fill', col)
          .on('mouseenter', function(evt, d) {
            const html = `<div class="hdr">${field}</div>
                          <div class="sub">${xField} = ${d[xField].toLocaleString()}</div>
                          <div>${field} = ${d.__y.toLocaleString()}</div>`;
            tooltip.html(html)
              .style('opacity', 1)
              .style('border-left', `4px solid ${col}`);
            d3.select(this).attr('r', 6);
          })
          .on('mousemove', function(evt) {
            const pad = 12;
            tooltip.style('left', `${evt.clientX + pad}px`).style('top', `${evt.clientY + pad}px`);
          })
          .on('mouseleave', function() {
            tooltip.style('opacity', 0);
            d3.select(this).attr('r', 4);
          });
      });

      // Legend
      const legend = d3.select('#legend');
      seriesFields.forEach(field => {
        const item = legend.append('div').attr('class','badge');
        item.append('span').attr('class','dot').style('background', colorFor(field));
        item.append('span').text(field);
      });
    }

    fileInput.addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;

      const reader = new FileReader();
      reader.onload = () => {
        const {rows, headers: hdrs} = parseCsv(String(reader.result || ''));
        rawRows = rows;
        headers = hdrs;
        buildSchema(rawRows, headers);
        render();
      };
      reader.readAsText(f);
    });

    xScaleSel.addEventListener('change', render);

    clearBtn.addEventListener('click', () => {
      rawRows = [];
      headers = [];
      xField = null;
      numericFields = [];
      seriesFields = [];
      schemaHint.textContent = 'Load one of your generated CSVs.';
      d3.select('#chart').selectAll('*').remove();
      d3.select('#legend').html('');
    });

    render();
  </script>
</body>
</html>