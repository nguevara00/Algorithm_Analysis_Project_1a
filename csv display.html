<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>CSV Plotter — Multiple Implementations</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --fg:#111827; --muted:#6b7280; --border:#e5e7eb; --card:#ffffff; --bg:#f8fafc; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--fg);
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif; }
  .container { max-width: 1120px; margin: 24px auto; padding: 0 16px; }
  h1 { font-size: 1.25rem; margin: 0 0 12px 0; }
  .card { background: var(--card); border:1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; }
  .row { display:flex; gap:12px; flex-wrap: wrap; align-items: center; }
  label { display:flex; align-items:center; gap:8px; }
  input[type="file"] { padding:6px 8px; }
  select, button { padding: 6px 10px; border: 1px solid var(--border); border-radius: 8px; background: #fff; }
  button { background:#f9fafb; cursor:pointer; }
  button:hover { background:#f3f4f6; }
  #chart { height: 540px; position: relative; }
  .legend { display:flex; gap:12px; flex-wrap: wrap; margin-top: 8px; }
  .badge { display:inline-flex; align-items:center; gap:8px; padding:4px 10px; border:1px solid var(--border);
    border-radius: 999px; background:#fff; font-size: 12px; }
  .dot { width:10px; height:10px; border-radius:999px; display:inline-block; }
  .footer { color: var(--muted); font-size: .92rem; margin-top: 12px; line-height: 1.35; }
  .axis text { font-size: 12px; fill: #374151; }
  .axis path, .axis line { stroke: #94a3b8; }
  .grid line { stroke: #e5e7eb; }
  .grid .domain { display: none; }
  .tooltip {
    position: fixed;
    pointer-events: none;
    background: #fff;
    border: 1px solid var(--border);
    box-shadow: 0 4px 14px rgba(0,0,0,0.12);
    border-radius: 10px;
    padding: 8px 10px;
    font-size: 12px;
    color: var(--fg);
    z-index: 20;
    white-space: nowrap;
  }
  .tooltip .hdr { font-weight: 600; margin-bottom: 2px; }
  .tooltip .sub { color: var(--muted); }
  .err { color:#b91c1c; font-weight:600; }
  code { background:#f1f5f9; padding:2px 6px; border-radius:6px; }
</style>
</head>
<body>
<div class="container">
  <h1>CSV Plotter (impl + x + metrics)</h1>

  <div class="card">
    <div class="row">
      <label>CSV file <input type="file" id="file" accept=".csv" /></label>
      <button id="useExample">Load example</button>

      <!-- NEW: filter by impl (case) -->
      <label>Case (impl)
        <select id="implFilter"></select>
      </label>

      <!-- NEW: compare two metric columns as two series -->
      <label><input type="checkbox" id="compareTwoMetrics"> Compare two metrics</label>

      <!-- NEW: second Y selector (only shown in compare mode) -->
      <label id="y2Wrap" style="display:none;">Y metric 2
        <select id="yCol2"></select>
      </label>

      <label>X column
        <select id="xCol"></select>
      </label>

      <label>Y metric
        <select id="yCol"></select>
      </label>

      <label>X scale
        <select id="xScale">
          <option value="linear" selected>linear</option>
          <option value="log2">log₂</option>
        </select>
      </label>

      <label><input type="checkbox" id="showLines" checked> Lines</label>
      <label><input type="checkbox" id="showDots" checked> Dots</label>
    </div>

    <div class="footer" id="status">
      Expected minimum columns: <code>impl</code> and one numeric x column (often <code>N</code> or <code>x</code>), plus at least one numeric metric column.
    </div>
  </div>

  <div id="chart" class="card"></div>
  <div id="legend" class="legend"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
  const exampleCsv = `impl,x,InSort_C,SelSort_C
best_case,100,0,4950
best_case,200,0,19900
average_case,100,2600,4950
average_case,200,10400,19900
worst_case,100,4950,4950
worst_case,200,19900,19900`;

  const fileInput = document.getElementById('file');
  const useExampleBtn = document.getElementById('useExample');

  // NEW controls
  const implFilterSel = document.getElementById('implFilter');
  const compareTwoChk = document.getElementById('compareTwoMetrics');
  const y2Wrap = document.getElementById('y2Wrap');
  const yColSel2 = document.getElementById('yCol2');

  const xColSel = document.getElementById('xCol');
  const yColSel = document.getElementById('yCol');
  const xScaleSel = document.getElementById('xScale');
  const showLinesChk = document.getElementById('showLines');
  const showDotsChk = document.getElementById('showDots');
  const statusEl = document.getElementById('status');

  // Tooltip
  const tooltip = d3.select('body').append('div')
    .attr('class', 'tooltip')
    .style('opacity', 0);

  let rowsRaw = [];
  let columns = [];

  function setStatus(msg, isErr=false) {
    statusEl.innerHTML = isErr ? `<span class="err">${msg}</span>` : msg;
  }

  function stripBOM(s) { return s.replace(/^\ufeff/, ''); }

  function shouldUseSci(maxAbs) {
    return maxAbs >= 1e6;
  }

  function makeTickFormatterSciOrPlain(maxAbs) {
    const sci = d3.format(".1e");
    const plain = (maxAbs >= 1e4) ? d3.format(",") : d3.format("~g");
    return shouldUseSci(maxAbs) ? sci : plain;
  }

  function fmtTooltip(v) {
    if (!Number.isFinite(v)) return '—';
    const av = Math.abs(v);
    if (av >= 1e6) return d3.format(".1e")(v);
    if (av >= 1e4) return d3.format(",")(v);
    return String(v);
  }

  function parseCsv(text) {
    const parsed = d3.csvParse(text.trim());
    parsed.columns = parsed.columns.map(stripBOM);

    // Fix BOM-polluted key in row objects
    parsed.forEach(r => {
      const bomImpl = Object.keys(r).find(k => stripBOM(k) === 'impl' && k !== 'impl');
      if (bomImpl && !r.impl) { r.impl = r[bomImpl]; delete r[bomImpl]; }
    });

    return parsed;
  }

  function guessXColumn(cols) {
    const preferred = ['N', 'x', 'n', 'size'];
    for (const p of preferred) if (cols.includes(p)) return p;
    // fallback: first non-impl column
    return cols.find(c => c !== 'impl') || null;
  }

  function numericColumnCandidates(parsed, colName) {
    // A column is "numeric" if at least one row parses to finite
    let ok = false;
    for (const r of parsed) {
      const v = +r[colName];
      if (Number.isFinite(v)) { ok = true; break; }
    }
    return ok;
  }

  function populateSelect(selectEl, opts, selected) {
    selectEl.innerHTML = '';
    opts.forEach(o => {
      const opt = document.createElement('option');
      opt.value = o;
      opt.textContent = o;
      if (o === selected) opt.selected = true;
      selectEl.appendChild(opt);
    });
  }

  function loadDataFromCsv(csvText) {
    const parsed = parseCsv(csvText);
    columns = parsed.columns.slice();

    if (!columns.includes('impl')) {
      setStatus("CSV must include a column named 'impl'.", true);
      rowsRaw = [];
      render();
      return;
    }

    // Find numeric columns (besides impl)
    const numericCols = columns.filter(c => c !== 'impl' && numericColumnCandidates(parsed, c));
    if (numericCols.length < 2) {
      setStatus("Need at least two numeric columns besides 'impl' (one for x and one metric).", true);
      rowsRaw = [];
      render();
      return;
    }

    const xGuess = guessXColumn(columns);
    const xCol = (xGuess && numericCols.includes(xGuess)) ? xGuess : numericCols[0];

    // choose y candidates excluding x
    const yCandidates = numericCols.filter(c => c !== xCol);
    const yCol = yCandidates[0] || numericCols[0];
    const yCol2 = yCandidates[1] || yCandidates[0] || yCol;

    populateSelect(xColSel, numericCols, xCol);
    populateSelect(yColSel, yCandidates, yCol);
    populateSelect(yColSel2, yCandidates, yCol2);

    // Enable/disable compare-two based on number of metrics available
    const canCompareTwo = yCandidates.length >= 2;
    compareTwoChk.disabled = !canCompareTwo;
    if (!canCompareTwo) compareTwoChk.checked = false;
    y2Wrap.style.display = compareTwoChk.checked ? 'inline-flex' : 'none';

    // Parse numeric values for numeric cols (keep impl as string)
    parsed.forEach(r => {
      numericCols.forEach(c => r[c] = +r[c]);
    });

    rowsRaw = parsed;

    // Populate impl filter dropdown with unique impl values
    const impls = Array.from(new Set(parsed.map(r => r.impl).filter(v => v != null && v !== ''))).sort();
    populateSelect(implFilterSel, ['(all)'].concat(impls), '(all)');

    setStatus(
      `Loaded ${rowsRaw.length} rows. X=<code>${xCol}</code>, Y=<code>${yCol}</code>. Implementations are grouped by <code>impl</code>.`
    );

    render();
  }

  // Controls
  useExampleBtn.addEventListener('click', () => loadDataFromCsv(exampleCsv));

  fileInput.addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => loadDataFromCsv(String(reader.result).replace(/\r\n/g, '\n'));
    reader.readAsText(f);
  });

  // NEW controls
  implFilterSel.addEventListener('change', render);

  compareTwoChk.addEventListener('change', () => {
    y2Wrap.style.display = compareTwoChk.checked ? 'inline-flex' : 'none';
    render();
  });

  yColSel2.addEventListener('change', render);

  xColSel.addEventListener('change', () => {
    // When x changes, update y options to exclude x
    const xCol = xColSel.value;
    const numericCols = columns.filter(c => c !== 'impl');
    const candidates = numericCols.filter(c => c !== xCol);

    const currentY1 = yColSel.value;
    const currentY2 = yColSel2.value;

    populateSelect(yColSel, candidates, candidates.includes(currentY1) ? currentY1 : candidates[0]);
    populateSelect(yColSel2, candidates, candidates.includes(currentY2) ? currentY2 : (candidates[1] || candidates[0]));

    // Disable compare if only one metric remains
    compareTwoChk.disabled = candidates.length < 2;
    if (candidates.length < 2) compareTwoChk.checked = false;
    y2Wrap.style.display = compareTwoChk.checked ? 'inline-flex' : 'none';

    render();
  });

  yColSel.addEventListener('change', render);
  xScaleSel.addEventListener('change', render);
  showLinesChk.addEventListener('change', render);
  showDotsChk.addEventListener('change', render);

  function cssSafe(s) { return String(s).replace(/[^a-zA-Z0-9_-]/g, '_'); }

  function render() {
    const container = d3.select('#chart');
    container.selectAll('*').remove();
    d3.select('#legend').html('');
    tooltip.style('opacity', 0);

    if (!rowsRaw.length) {
      container.append('div')
        .style('color', '#6b7280')
        .style('padding', '6px 2px')
        .text('Load a CSV (or click “Load example”).');
      return;
    }

    const xKey = xColSel.value;
    const yKey = yColSel.value;
    const yKey2 = yColSel2.value;

    const implFilter = implFilterSel.value;
    const useImplFilter = implFilter && implFilter !== '(all)';

    const useTwoMetrics = !!compareTwoChk.checked;

    // filter valid
    const rows = rowsRaw.filter(r =>
      r.impl != null && r.impl !== '' &&
      (!useImplFilter || r.impl === implFilter) &&
      Number.isFinite(r[xKey]) &&
      Number.isFinite(r[yKey]) &&
      (!useTwoMetrics || Number.isFinite(r[yKey2])) &&
      (xScaleSel.value === 'log2' ? r[xKey] > 0 : true)
    );

    if (!rows.length) {
      container.append('div')
        .style('color', '#b91c1c')
        .style('padding', '6px 2px')
        .text(`No valid rows after filtering. Check selected columns and filters.`);
      return;
    }

    // Build series:
    // - Normal mode: series grouped by impl, yKey is metric
    // - Compare mode: series are yKey and yKey2, using same filtered rows (often a single impl/case)
    let series = []; // {name, points, yMetric}
    if (!useTwoMetrics) {
      const byImpl = d3.groups(rows, d => d.impl);
      byImpl.forEach(([impl, arr]) => arr.sort((a,b)=>a[xKey]-b[xKey]));
      series = byImpl.map(([impl, arr]) => ({ name: impl, points: arr, yMetric: yKey }));
    } else {
      const pts = rows.slice().sort((a,b)=>a[xKey]-b[xKey]);
      series = [
        { name: yKey,  points: pts, yMetric: yKey },
        { name: yKey2, points: pts, yMetric: yKey2 }
      ];
    }

    const margin = {top: 20, right: 34, bottom: 56, left: 76};
    const width = Math.max(360, container.node().clientWidth) - margin.left - margin.right;
    const height = 540 - margin.top - margin.bottom;

    const svg = container.append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom);

    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    const xMin = d3.min(rows, d => d[xKey]);
    const xMax = d3.max(rows, d => d[xKey]);

    const yMax = !useTwoMetrics
      ? d3.max(rows, d => d[yKey])
      : d3.max(rows, d => Math.max(d[yKey], d[yKey2]));

    const xMode = xScaleSel.value;

    const x = (xMode === 'log2')
      ? d3.scaleLog().base(2).domain([Math.max(1e-9, xMin), xMax]).range([0, width])
      : d3.scaleLinear().domain([xMin, xMax]).range([0, width]);

    const y = d3.scaleLinear().domain([0, yMax]).nice().range([height, 0]);

    const xMaxAbs = Math.max(Math.abs(xMin || 0), Math.abs(xMax || 0));
    const yMaxAbs = Math.abs(yMax || 0);

    const xFmt = makeTickFormatterSciOrPlain(xMaxAbs);
    const yFmt = makeTickFormatterSciOrPlain(yMaxAbs);

    const xAxis = (xMode === 'log2')
      ? d3.axisBottom(x).ticks(10).tickFormat(xFmt)
      : d3.axisBottom(x).ticks(10).tickFormat(xFmt);

    const yAxis = d3.axisLeft(y).ticks(8).tickFormat(yFmt);

    const xGrid = d3.axisBottom(x).ticks(10).tickSize(-height).tickFormat('');
    const yGrid = d3.axisLeft(y).ticks(8).tickSize(-width).tickFormat('');

    g.append('g').attr('class','grid').attr('transform', `translate(0,${height})`).call(xGrid);
    g.append('g').attr('class','grid').call(yGrid);

    g.append('g').attr('class','axis').attr('transform', `translate(0,${height})`).call(xAxis);
    g.append('g').attr('class','axis').call(yAxis);

    g.append('text')
      .attr('x', width/2)
      .attr('y', height+42)
      .attr('text-anchor','middle')
      .text(xKey + (xMode === 'log2' ? ' (log₂)' : ''));

    g.append('text')
      .attr('transform','rotate(-90)')
      .attr('x', -height/2)
      .attr('y', -56)
      .attr('text-anchor','middle')
      .text(useTwoMetrics ? `${yKey} / ${yKey2}` : yKey);

    // Colors (stable-ish)
    const fixedColors = {
      best_case: '#2ca02c',
      average_case: '#1f77b4',
      worst_case: '#d62728'
    };
    const palette = ['#1f77b4','#d62728','#2ca02c','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];
    let pi = 0;
    const color = new Map();
    series.forEach(s => color.set(s.name, fixedColors[s.name] || palette[(pi++) % palette.length]));

    const doLines = !!showLinesChk.checked;
    const doDots  = !!showDotsChk.checked;

    const line = d3.line()
      .x(d => x(d.x))
      .y(d => y(d.y))
      .curve(d3.curveMonotoneX);

    series.forEach(s => {
      const col = color.get(s.name);

      const mapped = s.points.map(d => ({
        impl: s.name,
        x: d[xKey],
        y: d[s.yMetric]
      }));

      if (doLines) {
        g.append('path')
          .datum(mapped)
          .attr('fill','none')
          .attr('stroke', col)
          .attr('stroke-width', 2.5)
          .attr('d', line);
      }

      if (doDots) {
        g.selectAll(`.pt-${cssSafe(s.name)}`)
          .data(mapped)
          .enter().append('circle')
          .attr('class', `pt-${cssSafe(s.name)}`)
          .attr('r', 4)
          .attr('cx', d => x(d.x))
          .attr('cy', d => y(d.y))
          .attr('fill', col)
          .on('mouseenter', function(evt, d) {
            tooltip.html(
              `<div class="hdr">${d.impl}</div>
               <div class="sub">${xKey} = ${fmtTooltip(d.x)}</div>
               <div>${d.impl} = ${fmtTooltip(d.y)}</div>`
            )
            .style('opacity', 1)
            .style('border-left', `4px solid ${col}`);
            d3.select(this).attr('r', 6);
          })
          .on('mousemove', function(evt) {
            const pad = 12;
            tooltip.style('left', `${evt.clientX + pad}px`).style('top', `${evt.clientY + pad}px`);
          })
          .on('mouseleave', function() {
            tooltip.style('opacity', 0);
            d3.select(this).attr('r', 4);
          });
      }
    });

    // Legend
    const legend = d3.select('#legend');
    series.forEach(s => {
      const item = legend.append('div').attr('class','badge');
      item.append('span').attr('class','dot').style('background', color.get(s.name));
      item.append('span').text(s.name);
    });
  }

  // Load example on first paint
  loadDataFromCsv(exampleCsv);
</script>
</body>
</html>